# ECE4180复习

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018145835173.png" alt="image-20231018145835173" style="zoom:50%;" />

## Touch Pad

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231015200927804.png" alt="image-20231015200927804" style="zoom: 33%;" />

注意:Pullup Resistors. 就是正常的I2C连接。

是通过interrupt触发，当p26从高电位变成低电位，触发fallInterrupt();

```c++
#include <mbed.h>
#include <mpr121.h>
DigitalOut led1(LED1);
DigitalOut led2(LED2);
DigitalOut led3(LED3);
DigitalOut led4(LED4);
// Create the interrupt receiver object on pin 26
InterruptIn interrupt(p26);
// Setup the i2c bus on pins 9 and 10
I2C i2c(p9, p10);
// Setup the Mpr121:
// constructor(i2c object, i2c address of the mpr121)
Mpr121 mpr121(&i2c, Mpr121::ADD_VSS);

// Key hit/release interrupt routine
void fallInterrupt() {
  int key_code=0;
  int i=0;
  int value=mpr121.read(0x00);
  value +=mpr121.read(0x01)<<8;
  // LED demo mod
  i=0;
  // puts key number out to LEDs for demo
  for (i=0; i<12; i++) {
  if (((value>>i)&0x01)==1) key_code=i+1;
  }
  led4=key_code & 0x01;
  led3=(key_code>>1) & 0x01;
  led2=(key_code>>2) & 0x01;
  led1=(key_code>>3) & 0x01;
}

int main() {
  interrupt.fall(&fallInterrupt);
  interrupt.mode(PullUp);
  while (1) {led1 = 1;}
}
```









## I2C：

两条线：sda, scl.

通过frequency修改scl频率。

使用SPI的设备：

### **Lab1**:

#### Touch Switch:

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018150232749.png" alt="image-20231018150232749" style="zoom:33%;" />

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018150205154.png" alt="image-20231018150205154" style="zoom:33%;" />

代码：

```c++
#include <mbed.h>
#include <mpr121.h>
DigitalOut led1(LED1);
DigitalOut led2(LED2);
DigitalOut led3(LED3);
DigitalOut led4(LED4);
// Create the interrupt receiver object on pin 26
InterruptIn interrupt(p26);
// Setup the i2c bus on pins 9 and 10
I2C i2c(p9, p10);
// Setup the Mpr121:
// constructor(i2c object, i2c address of the mpr121)
Mpr121 mpr121(&i2c, Mpr121::ADD_VSS);

// Key hit/release interrupt routine
void fallInterrupt() {
  printf("\r\n\nHello, wave world!\n\r");
  int key_code=0;
  int i=0;
  int value=mpr121.read(0x00);
  value +=mpr121.read(0x01)<<8;
  // LED demo mod
  i=0;
  // puts key number out to LEDs for demo
  for (i=0; i<12; i++) {
  if (((value>>i)&0x01)==1) key_code=i+1;
  }
  led4=key_code & 0x01;
  led3=(key_code>>1) & 0x01;
  led2=(key_code>>2) & 0x01;
  led1=(key_code>>3) & 0x01;
}

int main() {
  interrupt.fall(&fallInterrupt);
  interrupt.mode(PullUp);
  while (1) {}
}

```

### Lab2

#### IMU

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018150501822.png" alt="image-20231018150501822" style="zoom:33%;" />



```c++
#ifndef MBED_I2C_H
#define MBED_I2C_H
#include "platform.h"
#include "PinNames.h"
#include "PeripheralNames.h"
#include "Base.h"
namespace mbed {

/* Class: I2C
 *  An I2C Master, used for communicating with I2C slave devices
 *
 * Example:
 * > // Read from I2C slave at address 0x62
 * >
 * > #include "mbed.h"
 * >
 * > I2C i2c(p28, p27);
 * >
 * > int main() {
 * >     int address = 0x62;
 * >     char data[2];
 * >     i2c.read(address, data, 2);
 * > }
 */
class I2C : public Base {
public:
    enum RxStatus {
        NoData
        , MasterGeneralCall
        , MasterWrite
        , MasterRead
    };
    enum Acknowledge {
          NoACK = 0
        , ACK   = 1
    };
    /* Constructor: I2C
     *  Create an I2C Master interface, connected to the specified pins
     *
     * Variables:
     *  sda - I2C data line pin
     *  scl - I2C clock line pin
     */
    I2C(PinName sda, PinName scl, const char *name = NULL);

    /* Function: frequency
     *  Set the frequency of the I2C interface
     *
     * Variables:
     *  hz - The bus frequency in hertz
     */
    void frequency(int hz);

    /* Function: read
     *  Read from an I2C slave
     *
     * Performs a complete read transaction. The bottom bit of
     * the address is forced to 1 to indicate a read.
     *
     * Variables:
     *  address - 8-bit I2C slave address [ addr | 1 ]
     *  data - Pointer to the byte-array to read data in to 
     *  length - Number of bytes to read
     *  repeated - Repeated start, true - don't send stop at end
     *  returns - 0 on success (ack), or non-0 on failure (nack)
     */ 
    int read(int address, char *data, int length, bool repeated = false); 

    /* Function: read
     *  Read a single byte from the I2C bus
     *
     * Variables:
     *  ack - indicates if the byte is to be acknowledged (1 = acknowledge)
     *  returns - the byte read
     */
    int read(int ack);

    /* Function: write
     *  Write to an I2C slave
     *
     * Performs a complete write transaction. The bottom bit of
     * the address is forced to 0 to indicate a write.
     *
     * Variables:
     *  address - 8-bit I2C slave address [ addr | 0 ]
     *  data - Pointer to the byte-array data to send 
     *  length - Number of bytes to send
     *  repeated - Repeated start, true - do not send stop at end
     *  returns - 0 on success (ack), or non-0 on failure (nack)
     */ 
    int write(int address, const char *data, int length, bool repeated = false);

    /* Function: write
     *  Write single byte out on the I2C bus
     *
     * Variables:
     *  data - data to write out on bus
     *  returns - a '1' if an ACK was received, a '0' otherwise
     */
    int write(int data);

    /* Function: start
     *  Creates a start condition on the I2C bus
     */

    void start(void);

    /* Function: stop
     *  Creates a stop condition on the I2C bus
     */
    void stop(void);

protected:

    void aquire();

    I2CName     _i2c;
    static I2C  *_owner;
    int         _hz;

};

} // namespace mbed

#endif

```

## SPI

一般有四条线： MOSI MISO SCLK CS。

```c++
/* mbed Microcontroller Library - SPI
 * Copyright (c) 2006-2009 ARM Limited. All rights reserved. 
 * sford
 */

#ifndef MBED_SPI_H
#define MBED_SPI_H

#include "platform.h"
#include "PinNames.h"
#include "PeripheralNames.h"
#include "Base.h"

namespace mbed {

/* Class: SPI
 *  A SPI Master, used for communicating with SPI slave devices
 *
 * The default format is set to 8-bits, mode 0, and a clock frequency of 1MHz
 *
 * Most SPI devices will also require Chip Select and Reset signals. These
 * can be controlled using <DigitalOut> pins
 *
 * Example:
 * > // Send a byte to a SPI slave, and record the response
 * >
 * > #include "mbed.h"
 * >
 * > SPI device(p5, p6, p7); // mosi, miso, sclk
 * >
 * > int main() {
 * >     int response = device.write(0xFF);
 * > }
 */ 
class SPI : public Base {

public:

    /* Constructor: SPI
     *  Create a SPI master connected to the specified pins
     *
     * Variables:
     *  mosi - SPI Master Out, Slave In pin
     *  miso - SPI Master In, Slave Out pin
     *  sclk - SPI Clock pin
     *  name - (optional) A string to identify the object     
     *
     * Pin Options:
     *  (5, 6, 7) or (11, 12, 13)
     *
     *  mosi or miso can be specfied as NOT_CONNECTED if not used
     */
    SPI(PinName mosi, PinName miso, PinName sclk, const char *name = NULL);

    /* Function: format
     *  Configure the data transmission format
     *
     * Variables:
     *  bits - Number of bits per SPI frame (4 - 16)
     *  mode - Clock polarity and phase mode (0 - 3)
     *
     * > mode | POL PHA 
     * > -----+--------	 
     * >   0  |  0   0 
     * >   1  |  0   1
     * >   2  |  1   0 
     * >   3  |  1   1
     */
    void format(int bits, int mode = 0);

    /* Function: frequency
     *  Set the spi bus clock frequency
     *
     * Variables:
     *  hz - SCLK frequency in hz (default = 1MHz)
     */
    void frequency(int hz = 1000000);

    /* Function: write
     *  Write to the SPI Slave and return the response
     *
     * Variables:
     *  value - Data to be sent to the SPI slave
     *  returns - Response from the SPI slave
    */
    int write(int value);

#ifdef MBED_RPC
    virtual const struct rpc_method *get_rpc_methods();
    static struct rpc_class *get_rpc_class();
#endif

protected:

	SPIName _spi;
	
	void aquire();
    static SPI *_owner; 
    int _bits;
    int _mode;
    int _hz;

};

} // namespace mbed

#endif

```

使用SPI的设备：

### **Lab1**:

#### Expander

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018150049062.png" alt="image-20231018150049062" style="zoom:33%;" />

```c++
#include "mbed.h"
#include "MCP23S17.h"
// Create SPI bus
SPI spi(p5, p6, p7);
// 
// Wiring Connections:
// mbed p5,p6,p7 are tied to MCP23S17 SI, SO, SCK pins
// mbed p20 to MCP23S17 CS
// MCP23S17 reset pin pulled high
// MCP23S17 GPA0 connected to GPB0 for loopback test
// A0, A1, A2 of the MCP23S17  are tied to ground on the breadboard, so the 8-bit address for writes is 0x40
// This is referred to as the opcode in the device datasheet
char Opcode = 0x40;

// Next create a MCP23S17
// mbed p20 is connected to ~chipSelect on the MCP23S17
MCP23S17 chip = MCP23S17(spi, p20, Opcode);

// Optional software reset - mbed p14 to MCP23S17 reset pin
// DigitalOut reset(p14);

DigitalOut led1(LED1); // mbed LED1 is used for test status display

int main() {
//  The MCP23S17 reset pin can just be pulled high, since it has a power on reset circuit.
//  The reset pin can be used for a software forced reset by pulling it low with an mbed GPIO pin.
//  But just leave it pulled high for this simple demo code.
//  After a power on reset, both IO ports default to input mode
//
//  Here is the optional code for a software reset
//  reset = 0;
//  wait_us(1);
//  reset = 1;
//
//  Set all 8 Port A bits to output direction
    chip.direction(PORT_A, 0x00);
//  Set all 8 Port B bits to input direction
    chip.direction(PORT_B, 0xFF);
    led1=0;
//  Start Loopback test sending out and reading back values
//  loopback test uses A0 and B0 pins - so use a wire to jumper those two pins on MCP23S17 together
    while (1) {
        // write 0xAA to MCP23S17 Port A
        chip.write(PORT_A, 0xAA);
        wait(.5);
        // read back value from MCP23S17 Port B and display B0 on mbed led1
        led1 = chip.read(PORT_B)& 0x01;
        // write 0x55 to MCP23S17 Port A
        chip.write(PORT_A, 0x55);
        wait(.5);
        // read back value from MCP23S17 Port B and display B0 on mbed led1
        led1 = chip.read(PORT_B)& 0x01;
        // led1 should blink slowly when it is all working
    }
}
```



### Lab2

#### SD card

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018151443194.png" alt="image-20231018151443194" style="zoom:33%;" />

```c++
#include "mbed.h"
#include "SDFileSystem.h"
 
SDFileSystem sd(p5, p6, p7, p8, "sd"); // the pinout on the mbed Cool Components workshop board
Serial pc(USBTX, USBRX);
int main() {
    printf("Hello World!\n");   
    
    mkdir("/sd/mydir", 0777);
    
    FILE *fp = fopen("/sd/mydir/sdtest.txt", "w");
    if(fp == NULL) {
        pc.printf("Fail!");
        error("Could not open file for write\n");
    }
    pc.printf("Nice!!");
    fprintf(fp, "Hello fun SD Card World!");
    fclose(fp); 
    
    fp = fopen("/sd/mydir/sdtest.txt", "r"); // Open the file for reading

    if (fp == NULL) {
        pc.printf("Reopen Fail!");
        error("Could not open file for read\n");
    }

    char buffer[27]; // Buffer to store the read data
    memset(buffer, 0, sizeof(buffer)); // Initialize the buffer

    size_t bytes_read = fread(buffer, 1, sizeof(buffer) - 1, fp); // Read data from the file
    
    pc.printf("Read Nice!");
    if (bytes_read > 0) {
        buffer[bytes_read] = '\0'; // Null-terminate the buffer
        printf("Read from file: %s\n", buffer);
    } else {
        printf("Error reading from file\n");
    }

    fclose(fp); // Close the file
    
    printf("Goodbye World!\n");
}

```



## Serial

UART或者RS232

```c++
#ifndef MBED_SERIAL_H
#define MBED_SERIAL_H

#include "platform.h"
#include "PinNames.h"
#include "PeripheralNames.h"
#include "Stream.h"
#include "FunctionPointer.h"

namespace mbed {

/* Class: Serial
 *  A serial port (UART) for communication with other serial devices
 *
 * Example:
 * > // Print "Hello World" to the PC
 * >
 * > #include "mbed.h"
 * >
 * > Serial pc(USBTX, USBRX);
 * >
 * > int main() {
 * >     pc.printf("Hello World\n");
 * > }
 */
class Serial : public Stream {

public:

    /* Constructor: Serial
     *  Create a Serial port, connected to the specified transmit and receive pins
     *
     * Variables:
     *  tx - Transmit pin 
     *  rx - Receive pin
     *
     *  Note: Either tx or rx may be specified as NC if unused
     */
    Serial(PinName tx, PinName rx, const char *name = NULL);

    /* Function: baud
     *  Set the baud rate of the serial port
     *  
     * Variables:
     *  baudrate - The baudrate of the serial port (default = 9600).
     */
    void baud(int baudrate);

    enum Parity {
        None = 0
        , Odd
        , Even
        , Forced1    
        , Forced0
    };

    enum IrqType {
        RxIrq = 0
        , TxIrq
    };

    /* Function: format
     *  Set the transmission format used by the Serial port
     *
     * Variables:
     *  bits - The number of bits in a word (5-8; default = 8)
     *  parity - The parity used (Serial::None, Serial::Odd, Serial::Even, Serial::Forced1, Serial::Forced0; default = Serial::None)
     *  stop - The number of stop bits (1 or 2; default = 1)
     */
    void format(int bits = 8, Parity parity = Serial::None, int stop_bits = 1); 

#if 0 // Inhereted from Stream, for documentation only

    /* Function: putc
     *  Write a character
     *
     * Variables:
     *  c - The character to write to the serial port
     */
    int putc(int c);

    /* Function: getc
     *  Read a character
     *
     * Variables:
     *  returns - The character read from the serial port
     */
    int getc();

    /* Function: printf
     *  Write a formated string
     *
     * Variables:
     *  format - A printf-style format string, followed by the 
     *      variables to use in formating the string.
     */
    int printf(const char* format, ...);

    /* Function: scanf
     *  Read a formated string 
     *
     * Variables:
     *  format - A scanf-style format string,
     *      followed by the pointers to variables to store the results. 
     */
    int scanf(const char* format, ...);
 
#endif
 
    /* Function: readable
     *  Determine if there is a character available to read
     *
     * Variables:
     *  returns - 1 if there is a character available to read, else 0
     */
    int readable();

    /* Function: writeable
     *  Determine if there is space available to write a character
     * 
     * Variables:
     *  returns - 1 if there is space to write a character, else 0
     */
    int writeable();

    /* Function: attach
     *  Attach a function to call whenever a serial interrupt is generated
     *
     * Variables:
     *  fptr - A pointer to a void function, or 0 to set as none
     *  type - Which serial interrupt to attach the member function to (Seriall::RxIrq for receive, TxIrq for transmit buffer empty)
     */
    void attach(void (*fptr)(void), IrqType type = RxIrq);

    /* Function: attach
     *  Attach a member function to call whenever a serial interrupt is generated
     *     
     * Variables:
     *  tptr - pointer to the object to call the member function on
     *  mptr - pointer to the member function to be called
     *  type - Which serial interrupt to attach the member function to (Seriall::RxIrq for receive, TxIrq for transmit buffer empty)
     */
    template<typename T>
    void attach(T* tptr, void (T::*mptr)(void), IrqType type = RxIrq) {
        if((mptr != NULL) && (tptr != NULL)) {
            _irq[type].attach(tptr, mptr);
            setup_interrupt(type);
        }
    }

#ifdef MBED_RPC
    virtual const struct rpc_method *get_rpc_methods();
    static struct rpc_class *get_rpc_class();
#endif

protected:

    void setup_interrupt(IrqType type);
    void remove_interrupt(IrqType type);

    virtual int _getc();
    virtual int _putc(int c);

    UARTName _uart;
    FunctionPointer _irq[2];
    int _uidx;

};

} // namespace mbed

#endif
```

使用Serial的设备：

### Lab2:

#### serial port

```c++
#include "mbed.h"

Serial pc(USBTX, USBRX); // Define a Serial object with USBTX and USBRX pins

int main() {
    pc.baud(9600); // Set the baud rate to 115200

    pc.printf("Custom Baud Rate Example\n");

    while(1) {
        // Send data over the serial port
        
        // Receive data from the serial port and echo it back
        if (pc.readable()) {
            char received_char = pc.getc(); // Read a character
            pc.putc(received_char);         // Send it back
        }
    }
}
```



#### LCD 

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018150736347.png" alt="image-20231018150736347" style="zoom:33%;" />

```c++
// uLCD-144-G2 basic text demo program for uLCD-4GL LCD driver library
//
#include "mbed.h"
#include "uLCD_4DGL.h"

uLCD_4DGL uLCD(p9,p10,p11); // serial tx, serial rx, reset pin;

int main()
{
    // basic printf demo = 16 by 18 characters on screen
    uLCD.printf("\nHello uLCD World\n"); //Default Green on black text
    uLCD.printf("\n  Starting Demo...");
    uLCD.text_width(4); //4X size text
    uLCD.text_height(4);
    uLCD.color(RED);
    for (int i=10; i>=0; --i) {
        uLCD.locate(1,2);
        uLCD.printf("%2D",i);
        wait(.5);
    }
}
```



## PwmOut：

```c++
#ifndef MBED_PWMOUT_H
#define MBED_PWMOUT_H

#include "platform.h"
#include "PinNames.h"
#include "PeripheralNames.h"
#include "Base.h"

namespace mbed {

/* Class: PwmOut
 *  A pulse-width modulation digital output
 *
 * Example
 * > // Fade a led on.
 * > #include "mbed.h"
 * >
 * > PwmOut led(LED1);
 * > 
 * > int main() {
 * >     while(1) {
 * >         led = led + 0.01;
 * >         wait(0.2);
 * >         if(led == 1.0) {
 * >             led = 0;
 * >         }
 * >     }
 * > }
 *
 *  Note that on the LPC1768 and LPC2368, the PWMs all share the same
 *  period - if you change the period for one, you change it for all.
 *  Although routines that change the period maintain the duty cycle
 *  for its PWM, all other PWMs will require their duty cycle to be
 *  refreshed.
 */
class PwmOut : public Base {

public:

    /* Constructor: PwmOut
     *  Create a PwmOut connected to the specified pin
     *
     * Variables:
     *  pin - PwmOut pin to connect to
     */
    PwmOut(PinName pin, const char *name = NULL);

    /* Function: write
     *  Set the ouput duty-cycle, specified as a percentage (float)
     *
     * Variables:
     *  value - A floating-point value representing the output duty-cycle, 
     *    specified as a percentage. The value should lie between
     *    0.0f (representing on 0%) and 1.0f (representing on 100%).
     *    Values outside this range will be saturated to 0.0f or 1.0f.	 
     */
    void write(float value);

    /* Function: read
     *  Return the current output duty-cycle setting, measured as a percentage (float)
     *
     * Variables:
     *  returns - A floating-point value representing the current duty-cycle being output on the pin, 
     *    measured as a percentage. The returned value will lie between
     *    0.0f (representing on 0%) and 1.0f (representing on 100%).
     *
     * Note:
     *  This value may not match exactly the value set by a previous <write>.
     */
    float read();
    
    /* Function: period
     *  Set the PWM period, specified in seconds (float), keeping the
     *  duty cycle the same.
     *
     *  Note:
     *   The resolution is currently in microseconds; periods smaller than this
     *   will be set to zero.
     */
    void period(float seconds);

    /* Function: period_ms
     *  Set the PWM period, specified in milli-seconds (int), keeping the
     *  duty cycle the same.
     */
    void period_ms(int ms);

    /* Function: period_us
     *  Set the PWM period, specified in micro-seconds (int), keeping the
     *  duty cycle the same.
     */
    void period_us(int us);

    /* Function: pulsewidth
     *  Set the PWM pulsewidth, specified in seconds (float), keeping the
     *  period the same.
     */
    void pulsewidth(float seconds);

    /* Function: pulsewidth_ms
     *  Set the PWM pulsewidth, specified in milli-seconds (int), keeping
     *  the period the same.
     */
    void pulsewidth_ms(int ms);

    /* Function: pulsewidth_us
     *  Set the PWM pulsewidth, specified in micro-seconds (int), keeping
     *  the period the same.
     */
    void pulsewidth_us(int us);

#ifdef MBED_OPERATORS
    /* Function: operator=
     *  A operator shorthand for <write()>
     */
    PwmOut& operator= (float value);
    PwmOut& operator= (PwmOut& rhs);

    /* Function: operator float()
     *  An operator shorthand for <read()>
     */
    operator float();
#endif

#ifdef MBED_RPC
    virtual const struct rpc_method *get_rpc_methods();
    static struct rpc_class *get_rpc_class();
#endif

protected:

    PWMName _pwm;

};

} // namespace mbed

#endif

```

使用PwmOut的设备：

### Lab2:

#### DC Motor

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018151200263.png" alt="image-20231018151200263" style="zoom:33%;" />

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018151324696.png" alt="image-20231018151324696" style="zoom:25%;" />

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018151344054.png" alt="image-20231018151344054" style="zoom: 25%;" />

```c++
#include "mbed.h"

DigitalOut myled(LED1);
DigitalOut Ctrl(p8);

int main() {
    while(1) {
        Ctrl = 1;
        myled = 1;
        wait(.2);
        Ctrl = 0;
        myled = 0;
        wait(.2);
    }
}
```

#### RC Servo:

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018152510839.png" alt="image-20231018152510839" style="zoom:33%;" />

```c++
#include "mbed.h"
#include "Servo.h"

Servo myservo(p21);
Serial pc(USBTX, USBRX);

int main() {
    printf("Servo Calibration Controls:\n");
    printf("1,2,3 - Position Servo (full left, middle, full right)\n");
    printf("4,5 - Decrease or Increase range\n");

    float range = 0.0005;
    float position = 0.5;
    
    while(1) {                   
        switch(pc.getc()) {
            case '1': position = 0.0; break;
            case '2': position = 0.5; break;
            case '3': position = 1.0; break;
            case '4': range += 0.0001; break; 
            case '5': range -= 0.0001; break; 
        }
        printf("position = %.1f, range = +/-%0.4f\n", position, range);
        myservo.calibrate(range, 45.0); 
        myservo = position;
    }
}
```



## AnalogIn:

The AnalogIn API returns a value from 0.0 to 1.0. A return value of 1.0 corresponds to an external analog voltage of 3.3V and 0.0 is 0.0V. 

```c++
/* mbed Microcontroller Library - AnalogIn
 * Copyright (c) 2006-2009 ARM Limited. All rights reserved.
 * sford
 */ 

#ifndef MBED_ANALOGIN_H
#define MBED_ANALOGIN_H

#include "platform.h"
#include "PinNames.h"
#include "PeripheralNames.h"
#include "Base.h"

namespace mbed {

/* Class: AnalogIn
 *  An analog input, used for reading the voltage on a pin 
 *
 * Example:
 * > // Print messages when the AnalogIn is greater than 50%
 * >
 * > #include "mbed.h"
 * >
 * > AnalogIn temperature(p20);
 * >
 * > int main() {
 * >     while(1) {
 * >         if(temperature > 0.5) {
 * >             printf("Too hot! (%f)", temperature.read());             
 * >         }
 * >     }
 * > }
 */
class AnalogIn :  public Base {

public:

    /* Constructor: AnalogIn
     *  Create an AnalogIn, connected to the specified pin
     *
     * Variables:
     *  pin - AnalogIn pin to connect to 
     *  name - (optional) A string to identify the object
     */
	AnalogIn(PinName pin, const char *name = NULL);
	
    /* Function: read
     * Read the input voltage, represented as a float in the range [0.0, 1.0]
     *
     * Variables:
     *  returns - A floating-point value representing the current input voltage,
     *            measured as a percentage
     */
    float read();	

    /* Function: read_u16
     *  Read the input voltage, represented as an unsigned short in the range [0x0, 0xFFFF]
     *
     * Variables:
     *  returns - 16-bit unsigned short representing the current input voltage,
     *            normalised to a 16-bit value 
     */
    unsigned short read_u16();

#ifdef MBED_OPERATORS
    /* Function: operator float
     *  An operator shorthand for <read()>
     *
     * The float() operator can be used as a shorthand for <read()> to simplify common code sequences
     *
     * Example:
     * > float x = volume.read();
     * > float x = volume;
     * >
     * > if(volume.read() > 0.25) { ... }
     * > if(volume > 0.25) { ... }
     */
    operator float();
#endif

#ifdef MBED_RPC
    virtual const struct rpc_method *get_rpc_methods();
    static struct rpc_class *get_rpc_class();
#endif

protected:

    ADCName _adc;
    
};

} // namespace mbed

#endif

```



## BusIn

```c++
/* mbed Microcontroller Library
 * Copyright (c) 2006-2013 ARM Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef MBED_BUSIN_H
#define MBED_BUSIN_H

#include "platform/platform.h"
#include "drivers/DigitalIn.h"
#include "platform/PlatformMutex.h"

namespace mbed {
/** \addtogroup drivers */
/** @{*/

/** A digital input bus, used for reading the state of a collection of pins
 *
 * @Note Synchronization level: Thread safe
 */
class BusIn {

public:
    /* Group: Configuration Methods */

    /** Create an BusIn, connected to the specified pins
     *
     * @param <n> DigitalIn pin to connect to bus bit <n> (p5-p30, NC)
     *
     * @note
     *  It is only required to specify as many pin variables as is required
     *  for the bus; the rest will default to NC (not connected)
     */
    BusIn(PinName p0, PinName p1 = NC, PinName p2 = NC, PinName p3 = NC,
          PinName p4 = NC, PinName p5 = NC, PinName p6 = NC, PinName p7 = NC,
          PinName p8 = NC, PinName p9 = NC, PinName p10 = NC, PinName p11 = NC,
          PinName p12 = NC, PinName p13 = NC, PinName p14 = NC, PinName p15 = NC);

    BusIn(PinName pins[16]);

    virtual ~BusIn();

    /** Read the value of the input bus
     *
     *  @returns
     *   An integer with each bit corresponding to the value read from the associated DigitalIn pin
     */
    int read();

    /** Set the input pin mode
     *
     *  @param mode PullUp, PullDown, PullNone
     */
    void mode(PinMode pull);

    /** Binary mask of bus pins connected to actual pins (not NC pins)
     *  If bus pin is in NC state make corresponding bit will be cleared (set to 0), else bit will be set to 1
     *
     *  @returns
     *    Binary mask of connected pins
     */
    int mask() {
        // No lock needed since _nc_mask is not modified outside the constructor
        return _nc_mask;
    }

    /** A shorthand for read()
     */
    operator int();

    /** Access to particular bit in random-iterator fashion
     */
    DigitalIn & operator[] (int index);

protected:
    DigitalIn* _pin[16];

    /** Mask of bus's NC pins
     * If bit[n] is set to 1 - pin is connected
     * if bit[n] is cleared - pin is not connected (NC)
     */
    int _nc_mask;

    PlatformMutex _mutex;

    /* disallow copy constructor and assignment operators */
private:
    virtual void lock();
    virtual void unlock();
    BusIn(const BusIn&);
    BusIn & operator = (const BusIn&);
};

} // namespace mbed

#endif

/** @}*/
```

### Navigation Switch

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018153748679.png" alt="image-20231018153748679" style="zoom:33%;" />

```c++
#include "mbed.h"

BusOut mbedleds(LED1,LED2,LED3,LED4);
//BusOut/In is faster than multiple DigitalOut/Ins

class Nav_Switch
{
public:
    Nav_Switch(PinName up,PinName down,PinName left,PinName right,PinName fire);
    int read();
//boolean functions to test each switch
    bool up();
    bool down();
    bool left();
    bool right();
    bool fire();
//automatic read on RHS
    operator int ();
//index to any switch array style
    bool operator[](int index) {
        return _pins[index];
    };
private:
    BusIn _pins;

};
Nav_Switch::Nav_Switch (PinName up,PinName down,PinName left,PinName right,PinName fire):
    _pins(up, down, left, right, fire)
{
    _pins.mode(PullUp); //needed if pullups not on board or a bare nav switch is used - delete otherwise
    wait(0.001); //delays just a bit for pullups to pull inputs high
}
inline bool Nav_Switch::up()
{
    return !(_pins[0]);
}
inline bool Nav_Switch::down()
{
    return !(_pins[1]);
}
inline bool Nav_Switch::left()
{
    return !(_pins[2]);
}
inline bool Nav_Switch::right()
{
    return !(_pins[3]);
}
inline bool Nav_Switch::fire()
{
    return !(_pins[4]);
}
inline int Nav_Switch::read()
{
    return _pins.read();
}
inline Nav_Switch::operator int ()
{
    return _pins.read();
}

Nav_Switch myNav( p26, p29, p28, p30, p27); //pin order on Sparkfun breakout

int main()
{
    while(1) {
        //with pullups a button hit is a "0" - "~" inverts data to leds
        mbedleds = ~(myNav & 0x0F); //update leds with nav switch direction inputs
        if(myNav.fire()) mbedleds = 0x0F; //special all leds on case for fire (center button)
        //or use - if(myNav[4]==0) mbedleds = 0x0F; //can index a switch bit like this
        wait(0.02);
    }
}

```

#### Usbmouse_Navswitch

```c++
#include "mbed.h"
#include "USBMouse.h"
//USB mouse demo using a 5-way Navigation Switch (Digital Joystick)
//Needs USB connector breakout with D+, D-, and Gnd to mbed LLP1768
USBMouse mouse;

class Nav_Switch
{
public:
    Nav_Switch(PinName up,PinName down,PinName left,PinName right,PinName fire);
    int read();
//boolean functions to test each switch
    bool up();
    bool down();
    bool left();
    bool right();
    bool fire();
//automatic read on RHS
    operator int ();
//index to any switch array style
    bool operator[](int index) {
        return _pins[index];
    };
private:
    BusIn _pins;

};
Nav_Switch::Nav_Switch (PinName up,PinName down,PinName left,PinName right,PinName fire):
    _pins(up, down, left, right, fire)
{
    _pins.mode(PullUp); //needed if pullups not on board or a bare nav switch is used - delete otherwise
    wait(0.001); //delays just a bit for pullups to pull inputs high
}
inline bool Nav_Switch::up()
{
    return !(_pins[0]);
}
inline bool Nav_Switch::down()
{
    return !(_pins[1]);
}
inline bool Nav_Switch::left()
{
    return !(_pins[2]);
}
inline bool Nav_Switch::right()
{
    return !(_pins[3]);
}
inline bool Nav_Switch::fire()
{
    return !(_pins[4]);
}
inline int Nav_Switch::read()
{
    return _pins.read();
}
inline Nav_Switch::operator int ()
{
    return _pins.read();
}

Nav_Switch myNav( p9, p6, p7, p5, p8); //pin order on Sparkfun Nav SW breakout

int main()
{
    int16_t x = 0;
    int16_t y = 0;
    uint8_t left_click = 0;
    while (1) {
        //check relative mouse movement
        x=0;
        y=0;
        if (myNav.up()) x=-1;
        if (myNav.down()) x=1;
        if (myNav.left()) y=1;
        if (myNav.right()) y=-1;
        //check mouse left button click
        if (myNav.fire()) left_click = 1;
        if (!myNav.fire())left_click = 0;
        //send a mouse data packet to PC
        mouse.update(x, y, left_click, 0);
        wait(0.001);
    }
}
```

## BusOut

```c++
#ifndef MBED_BUSOUT_H
#define MBED_BUSOUT_H

#include "platform.h" 
#include "PinNames.h"
#include "PeripheralNames.h"
#include "Base.h"
#include "DigitalOut.h"

namespace mbed {

/* Class: BusOut
 *  A digital output bus, used for setting the state of a collection of pins
 */
class BusOut : public Base {

public:

    /* Group: Configuration Methods */

    /* Constructor: BusOut
     *  Create an BusOut, connected to the specified pins
     *
     * Variables:
     *  p<n> - DigitalOut pin to connect to bus bit <n> (p5-p30, NC)
     *
     * Note:
     *  It is only required to specify as many pin variables as is required
     *  for the bus; the rest will default to NC (not connected)
   	 */ 
    BusOut(PinName p0, PinName p1 = NC, PinName p2 = NC, PinName p3 = NC,
           PinName p4 = NC, PinName p5 = NC, PinName p6 = NC, PinName p7 = NC,
           PinName p8 = NC, PinName p9 = NC, PinName p10 = NC, PinName p11 = NC,
           PinName p12 = NC, PinName p13 = NC, PinName p14 = NC, PinName p15 = NC, 
           const char *name = NULL);

    BusOut(PinName pins[16], const char *name = NULL);

    virtual ~BusOut();

    /* Group: Access Methods */
		
    /* Function: write
     *  Write the value to the output bus
     *
     * Variables:
     *  value - An integer specifying a bit to write for every corresponding DigitalOut pin
     */
    void write(int value);

		
    /* Function: read
     *  Read the value currently output on the bus
     *
     * Variables:
     *  returns - An integer with each bit corresponding to associated DigitalOut pin setting
     */
    int read();

#ifdef MBED_OPERATORS
    /* Group: Access Method Shorthand */
	   
   	/* Function: operator=
     *  A shorthand for <write>
     */
    BusOut& operator= (int v);
    BusOut& operator= (BusOut& rhs);

    /* Function: operator int()
     *  A shorthand for <read>
     */
    operator int();
#endif

#ifdef MBED_RPC
    virtual const struct rpc_method *get_rpc_methods();
    static struct rpc_class *get_rpc_class();
#endif

protected:

    DigitalOut* _pin[16];

#ifdef MBED_RPC
    static void construct(const char *arguments, char *res);
#endif
			
};

} // namespace mbed

#endif


```



## Ticker

```c++
#ifndef MBED_TICKER_H
#define MBED_TICKER_H

#include "TimerEvent.h"
#include "FunctionPointer.h"

namespace mbed {

/* Class: Ticker
 *  A Ticker is used to call a function at a recurring interval
 *
 * You can use as many seperate Ticker objects as you require. 
 *
 * Example:
 * > // Toggle the blinking led after 5 seconds
 * >
 * > #include "mbed.h"
 * > 
 * > Ticker timer;
 * > DigitalOut led1(LED1);
 * > DigitalOut led2(LED2);
 * > 
 * > int flip = 0;
 * > 
 * > void attime() {
 * >     flip = !flip;
 * > }
 * >
 * > int main() {
 * >     timer.attach(&attime, 5);
 * >     while(1) {
 * >         if(flip == 0) {
 * >             led1 = !led1;
 * >         } else {
 * >             led2 = !led2;
 * >         }
 * >         wait(0.2);
 * >     }
 * > }
 *
 */
class Ticker : public TimerEvent {

public:

    /* Function: attach
     *  Attach a function to be called by the Ticker, specifiying the interval in seconds
     *     
     * Variables:
     *  fptr - pointer to the function to be called
     *  t - the time between calls in seconds
     */
    void attach(void (*fptr)(void), float t) {
        attach_us(fptr, t * 1000000.0f);
    }
    
    /* Function: attach
     *  Attach a member function to be called by the Ticker, specifiying the interval in seconds
     *     
     * Variables:
     *  tptr - pointer to the object to call the member function on
     *  mptr - pointer to the member function to be called
     *  t - the time between calls in seconds
     */
    template<typename T>
    void attach(T* tptr, void (T::*mptr)(void), float t) {
        attach_us(tptr, mptr, t * 1000000.0f);
    }
    
    /* Function: attach_us
     *  Attach a function to be called by the Ticker, specifiying the interval in micro-seconds
     *     
     * Variables:
     *  fptr - pointer to the function to be called
     *  t - the time between calls in micro-seconds
     */
    void attach_us(void (*fptr)(void), unsigned int t) {
        _function.attach(fptr);
        setup(t);
    }

    /* Function: attach_us
     *  Attach a member function to be called by the Ticker, specifiying the interval in micro-seconds
     *     
     * Variables:
     *  tptr - pointer to the object to call the member function on
     *  mptr - pointer to the member function to be called
     *  t - the time between calls in micro-seconds
     */    
    template<typename T>
    void attach_us(T* tptr, void (T::*mptr)(void), unsigned int t) {
        _function.attach(tptr, mptr);
        setup(t);
    }
    
    /* Function: detach
     *  Detach the function
     */        
    void detach();
protected:
    void setup(unsigned int t);
    virtual void handler();

    unsigned int _delay;
    FunctionPointer _function;
};
} // namespace mbed
#endif
```



<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018161612242.png" alt="image-20231018161612242" style="zoom:33%;" />

```c++
#include "mbed.h"
 
Ticker flipper1;
Ticker flipper2;
Ticker flipper3;
Ticker flipper4;

DigitalOut led1(LED1);
DigitalOut led2(LED2);
DigitalOut led3(LED3);
DigitalOut led4(LED4);
 
void flip1() {
    led1 = !led1;
}

void flip2() {
    led2 = !led2;
}

void flip3() {
    led3 = !led3;
}

void flip4() {
    led4 = !led4;
}

int main() {
    flipper1.attach(&flip1, 1.0); // the address of the function to be attached (flip) and the interval (2 seconds)
    flipper2.attach(&flip2, 2.0);
    flipper3.attach(&flip3, 4.0);
    flipper4.attach(&flip4, 8.0);
    // spin in a main loop. flipper will interrupt it to call flip
    while(1) {
    }
}
```

## DigitalIn

```c++
#ifndef MBED_DIGITALIN_H
#define MBED_DIGITALIN_H

#include "platform.h"
#include "PinNames.h"
#include "PeripheralNames.h"
#include "Base.h"

namespace mbed {

/* Class: DigitalIn
 *  A digital input, used for reading the state of a pin
 *
 * Example:
 * > // Flash an LED while a DigitalIn is true
 * >
 * > #include "mbed.h"
 * >
 * > DigitalIn enable(p5);
 * > DigitalOut led(LED1);
 * >
 * > int main() {
 * >     while(1) {
 * >         if(enable) {
 * >             led = !led;
 * >         }
 * >         wait(0.25);
 * >     }
 * > }
 */
class DigitalIn : public Base {

public:

    /* Constructor: DigitalIn
     *  Create a DigitalIn connected to the specified pin
     *
     * Variables:
     *  pin - DigitalIn pin to connect to
     *  name - (optional) A string to identify the object
     */
    DigitalIn(PinName pin, const char *name = NULL);

    /* Function: read
     *  Read the input, represented as 0 or 1 (int)
     *
     * Variables:
     *  returns - An integer representing the state of the input pin, 
     *      0 for logical 0 and 1 for logical 1
     */
    int read() {
        return ((_gpio->FIOPIN & _mask) ? 1 : 0);
    }


    /* Function: mode
     *  Set the input pin mode
     *
     * Variables:
     *  mode - PullUp, PullDown, PullNone, OpenDrain
     */
    void mode(PinMode pull);
    
#ifdef MBED_OPERATORS    
    /* Function: operator int()
     *  An operator shorthand for <read()>
     */
    operator int() {
        return read();
    }

#endif

#ifdef MBED_RPC
    virtual const struct rpc_method *get_rpc_methods();
    static struct rpc_class *get_rpc_class();
#endif

protected:

    PinName             _pin;
    LPC_GPIO_TypeDef    *_gpio;
    uint32_t            _mask;

};

} // namespace mbed

#endif


```



## DigitalOut

```c++
#ifndef MBED_DIGITALOUT_H
#define MBED_DIGITALOUT_H

#include "platform.h"
#include "PinNames.h"
#include "PeripheralNames.h"
#include "Base.h"

namespace mbed {

/* Class: DigitalOut
 *  A digital output, used for setting the state of a pin
 *
 * Example:
 * > // Toggle a LED
 * > #include "mbed.h"
 * >
 * > DigitalOut led(LED1);
 * >
 * > int main() {
 * >     while(1) {
 * >         led = !led;
 * >         wait(0.2);
 * >     }
 * > }
 */
class DigitalOut : public Base {

public:

    /* Constructor: DigitalOut
     *  Create a DigitalOut connected to the specified pin
     *
     * Variables:
     *  pin - DigitalOut pin to connect to
     */
    DigitalOut(PinName pin, const char* name = NULL);

    /* Function: write
     *  Set the output, specified as 0 or 1 (int)
     *
     * Variables:
     *  value - An integer specifying the pin output value, 
     *      0 for logical 0 and 1 (or any other non-zero value) for logical 1 
     */
    void write(int value) {
        if(value) {
            _gpio->FIOSET = _mask;
        } else {
            _gpio->FIOCLR = _mask;
        }
    }

    /* Function: read
     *  Return the output setting, represented as 0 or 1 (int)
     *
     * Variables:
     *  returns - An integer representing the output setting of the pin, 
     *      0 for logical 0 and 1 for logical 1
     */
    int read() {
        return ((_gpio->FIOPIN & _mask) ? 1 : 0);
    }


#ifdef MBED_OPERATORS
    /* Function: operator=
     *  A shorthand for <write>
     */
    DigitalOut& operator= (int value) {
        write(value);
        return *this;
    }

    DigitalOut& operator= (DigitalOut& rhs) {
        write(rhs.read());
        return *this;
    }

    
    /* Function: operator int()
     *  A shorthand for <read>
     */
    operator int() {
        return read();
    }

#endif

#ifdef MBED_RPC
    virtual const struct rpc_method *get_rpc_methods();
    static struct rpc_class *get_rpc_class();
#endif

protected:

    PinName             _pin;
    LPC_GPIO_TypeDef    *_gpio;
    uint32_t            _mask;


};

} // namespace mbed

#endif 
```



## AnalogOut:

```c++
/* mbed Microcontroller Library - AnalogOut
 * Copyright (c) 2006-2009 ARM Limited. All rights reserved.
 * sford
 */ 
 
#ifndef MBED_ANALOGOUT_H
#define MBED_ANALOGOUT_H

#include "platform.h"
#include "PinNames.h"
#include "PeripheralNames.h"
#include "Base.h"

namespace mbed {

/* Class: AnalogOut
 *  An analog output, used for setting the voltage on a pin
 *
 * Example:
 * > // Make a sawtooth output
 * > 
 * > #include "mbed.h"
 * > 
 * > AnalogOut tri(p18);
 * > int main() {
 * >     while(1) {
 * >         tri = tri + 0.01;
 * >         wait_us(1);
 * >         if(tri == 1) {
 * >             tri = 0;
 * >         }
 * >     }
 * > }
 */
class AnalogOut : public Base {

public:

	/* Constructor: AnalogOut
	 *  Create an AnalogOut connected to the specified pin
	 * 
	 * Variables:
	 *  pin - AnalogOut pin to connect to (18)
	 */
	AnalogOut(PinName pin, const char *name = NULL);
	
    /* Function: write
     *  Set the output voltage, specified as a percentage (float)
     *
     * Variables:
     *  percent - A floating-point value representing the output voltage, 
     *    specified as a percentage. The value should lie between
     *    0.0f (representing 0v / 0%) and 1.0f (representing 3.3v / 100%).
     *    Values outside this range will be saturated to 0.0f or 1.0f.	 
     */
    void write(float value);
    
    /* Function: write_u16
     *  Set the output voltage, represented as an unsigned short in the range [0x0, 0xFFFF]
     *
     * Variables:
     *  value - 16-bit unsigned short representing the output voltage,
     *            normalised to a 16-bit value (0x0000 = 0v, 0xFFFF = 3.3v)
     */
    void write_u16(unsigned short value);

    /* Function: read
     *  Return the current output voltage setting, measured as a percentage (float)
     *
     * Variables:
     *  returns - A floating-point value representing the current voltage being output on the pin, 
     *    measured as a percentage. The returned value will lie between
     *    0.0f (representing 0v / 0%) and 1.0f (representing 3.3v / 100%).
     *
     * Note:
     *  This value may not match exactly the value set by a previous <write>.
     */	
    float read();


#ifdef MBED_OPERATORS
    /* Function: operator=
     *  An operator shorthand for <write()>
     */
	AnalogOut& operator= (float percent);
	AnalogOut& operator= (AnalogOut& rhs);

    /* Function: operator float()
     *  An operator shorthand for <read()>
     */	
	operator float();
#endif

#ifdef MBED_RPC
    virtual const struct rpc_method *get_rpc_methods();
    static struct rpc_class *get_rpc_class();
#endif

protected:

	DACName _dac;

};

} // namespace mbed

#endif


```



## Other components

### SPST pushbuttons

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018152627687.png" alt="image-20231018152627687" style="zoom: 25%;" />

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018153029797.png" alt="image-20231018153029797"  />

![image-20231018152958039](/Users/pb/Documents/My-study-notes/pictures/image-20231018152958039.png)

![image-20231018153225145](/Users/pb/Documents/My-study-notes/pictures/image-20231018153225145.png)

![image-20231018153309452](/Users/pb/Documents/My-study-notes/pictures/image-20231018153309452.png)

![image-20231018153248013](/Users/pb/Documents/My-study-notes/pictures/image-20231018153248013.png)

通过Pushbutton控制LED:

```c++
#include "mbed.h"
InterruptIn Button1(p8);//专门处理Interrupt
InterruptIn Button2(p9);
PwmOut myled(p21);
float count = 1.0;
//Function to call when interrupt occurs
void Add(){
    if(count>0){
        count -=0.1;
    }
}
void Sub(){
    if(count<1){
        count +=0.1;
    }
}
int main() {

    Button1.mode(PullUp);
    Button2.mode(PullUp);
    Button1.fall(&Add);
    Button2.rise(&Sub);
    while(1) {
    myled = count;
  }
}
```



### RGB LED

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018153620402.png" alt="image-20231018153620402" style="zoom:33%;" />

```c++
#include "mbed.h"
//Class to control an RGB LED using three PWM pins
class RGBLed
{
public:
    RGBLed(PinName redpin, PinName greenpin, PinName bluepin);
    void write(float red,float green, float blue);
private:
    PwmOut _redpin;
    PwmOut _greenpin;
    PwmOut _bluepin;
};

RGBLed::RGBLed (PinName redpin, PinName greenpin, PinName bluepin)
    : _redpin(redpin), _greenpin(greenpin), _bluepin(bluepin)
{
    //50Hz PWM clock default a bit too low, go to 2000Hz (less flicker)
    _redpin.period(0.0005);
}

void RGBLed::write(float red,float green, float blue)
{
    _redpin = red;
    _greenpin = green;
    _bluepin = blue;
}
//class could be moved to include file


//Setup RGB led using PWM pins and class
RGBLed myRGBled(p23,p22,p21); //RGB PWM pins

int main()
{
    while(1) {
        myRGBled.write(1.0,0.0,0.0); //red
        wait(2.0);
        myRGBled.write(0.0,1.0,0.0); //green
        wait(2.0);
        myRGBled.write(0.0,0.0,1.0); //blue
        wait(2.0);
        myRGBled.write(1.0,0.2,0.0); //yellow = red + some green
        wait(2.0);
        //white with a slow fade to black dimming effect
        for (float x=1.0; x>=0.0001; x=x*0.99) {
            myRGBled.write(x, x, x);
            wait(0.005);
        }
        wait(2.0);
    }
}
```



### Ethernet

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018154925250.png" alt="image-20231018154925250" style="zoom:33%;" />

```c++
#include "mbed.h"

Ethernet eth;

int main() {
    char buf[0x600];

    while(1) {
        int size = eth.receive();
        if(size > 0) {
            eth.read(buf, size);
            printf("Destination:  %02X:%02X:%02X:%02X:%02X:%02X\n",
                    buf[0], buf[1], buf[2], buf[3], buf[4], buf[5]);
            printf("Source: %02X:%02X:%02X:%02X:%02X:%02X\n",
                    buf[6], buf[7], buf[8], buf[9], buf[10], buf[11]);
        }

        wait(1);
    }
}
```

### Relay

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018155050823.png" alt="image-20231018155050823" style="zoom:33%;" />

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018155211207.png" alt="image-20231018155211207" style="zoom:33%;" />

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018155239707.png" alt="image-20231018155239707" style="zoom:33%;" />

### H-Bridge

Dual has 8 MOSFET

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018155425027.png" alt="image-20231018155425027" style="zoom:33%;" />

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018155522639.png" alt="image-20231018155522639" style="zoom:33%;" />

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018155555082.png" alt="image-20231018155555082" style="zoom:33%;" />

### MEMS Microphone

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018155832493.png" alt="image-20231018155832493" style="zoom:33%;" />

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018155857332.png" alt="image-20231018155857332" style="zoom:33%;" />

```c++
#include "mbed.h"
//Adafruit MEMs SPW2430 microphone demo
BusOut myleds(LED1,LED2,LED3,LED4);

class microphone
{
public :
    microphone(PinName pin);
    float read();
    operator float ();
private :
    AnalogIn _pin;
};
microphone::microphone (PinName pin):
    _pin(pin)
{
}
float microphone::read()
{
    return _pin.read();
}
inline microphone::operator float ()
{
    return _pin.read();
}

microphone mymicrophone(p16);

int main()
{
    while(1) {
//read in, subtract 0.67 DC bias, take absolute value, and scale up .1Vpp to 15 for builtin LED display
        myleds = int(abs((mymicrophone - (0.67/3.3)))*500.0);
//Use an 8kHz audio sample rate (phone quality audio);
        wait(1.0/8000.0);
    }
}
```

### Speaker and Amp

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018155950411.png" alt="image-20231018155950411" style="zoom:33%;" />

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018160236706.png" alt="image-20231018160236706" style="zoom:33%;" />

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018160303134.png" alt="image-20231018160303134" style="zoom:33%;" />



<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018160332304.png" alt="image-20231018160332304" style="zoom:33%;" />

![image-20231018160526071](/Users/pb/Documents/My-study-notes/pictures/image-20231018160526071.png)

![image-20231018160454491](/Users/pb/Documents/My-study-notes/pictures/image-20231018160454491.png)

![image-20231018160435333](/Users/pb/Documents/My-study-notes/pictures/image-20231018160435333.png)

### Wi - Fi

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018160908267.png" alt="image-20231018160908267" style="zoom:33%;" />

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018160932320.png" alt="image-20231018160932320" style="zoom:33%;" />

###  Rotary Pulse Generator 

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018161020725.png" alt="image-20231018161020725" style="zoom:33%;" />

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018161153735.png" alt="image-20231018161153735" style="zoom:33%;" />

```c++
#include "mbed.h"
#include "PinDetect.h"
//See http://makeatronics.blogspot.com/2013/02/efficiently-reading-quadrature-with.html
//for a detailed explanation of the RPG encoder counting algorithm
//uses Sparkfun RPG with RGB led on breakout board (#15141,11722,10597)
//place RPG PCB across a breadboard power bus strip for easier pin hookup!
InterruptIn RPG_A(p14,PullUp);//encoder A and B pins/bits use interrupts
InterruptIn RPG_B(p15,PullUp);
PinDetect RPG_PB(p16); //encode pushbutton switch "SW" on PCB
//PWM setup for RGB LED in enocder
PwmOut red(p21);//"R" pin
PwmOut blue(p22);//"G" pin
PwmOut green(p23);//"B" pin
//Note: also tie RPG PCB "C" pin to ground, "+" pin to 3.3
//mbed status leds
DigitalOut ledPB(LED1);
DigitalOut red_adjust_mode(LED2);
DigitalOut green_adjust_mode(LED3);
DigitalOut blue_adjust_mode(LED4);
//Serial pc(USBTX,USBRX);
volatile int old_enc = 0;
volatile int new_enc = 0;
volatile int enc_count = 0;
//Instead of a slow 16 case statement use a faster table lookup of truth table
//index table with (previous encoder AB value<<2 | current current encoder AB value) 
//to find -1(CCW),0,or 1(CW) change in count each time a bit changes state
//Always want Interrupt routines to run fast!
//const puts data in read only Flash instead of RAM
const int lookup_table[] = {0,-1,1,0,1,0,0,-1,-1,0,0,1,0,1,-1,0};
//Encoder bit change interrupt service routine
//called whenever one of the two A,B encoder bits change state
void Enc_change_ISR(void)
{
    new_enc = RPG_A<<1 | RPG_B;//current encoder bits
    //check truth table for -1,0 or +1 added to count
    enc_count = enc_count + lookup_table[old_enc<<2 | new_enc];
    old_enc = new_enc;
}
//debounced RPG pushbutton switch callback
void PB_callback(void)
{
    ledPB= !ledPB;
}
int main()
{
//turn off built-in RPG encoder RGB led
    red = 1.0;//PWM value 1.0 is "off", 0.0 is full "on"
    green = 1.0;
    blue = 1.0;
//current color adjust set to red
    red_adjust_mode = 1;
//debounce RPG center pushbutton
    RPG_PB.mode(PullDown);
    RPG_PB.attach_deasserted(&PB_callback);
    RPG_PB.setSampleFrequency();
// generate an interrupt on any change in either encoder bit (A or B)
    RPG_A.rise(&Enc_change_ISR);
    RPG_A.fall(&Enc_change_ISR);
    RPG_B.rise(&Enc_change_ISR);
    RPG_B.fall(&Enc_change_ISR);
    while (true) {
        // Scale/limit count to 0..100
        if (enc_count>100) enc_count = 100;
        if (enc_count<0) enc_count = 0;
        red = 1.0 - enc_count/100.0;
//        pc.printf("%D\n\r",enc_count);
    }
}
```

### LIDAR TOF Distance Sensor 

![image-20231018161253183](/Users/pb/Documents/My-study-notes/pictures/image-20231018161253183.png)

```c++
#include "mbed.h"
#include "XNucleo53L0A1.h"
#include <stdio.h>
Serial pc(USBTX,USBRX);
DigitalOut shdn(p26);
// This VL53L0X board test application performs a range measurement in polling mode
// Use 3.3(Vout) for Vin, p28 for SDA, p27 for SCL, P26 for shdn on mbed LPC1768

//I2C sensor pins
#define VL53L0_I2C_SDA   p28
#define VL53L0_I2C_SCL   p27

static XNucleo53L0A1 *board=NULL;

int main()
{
    int status;
    uint32_t distance;
    DevI2C *device_i2c = new DevI2C(VL53L0_I2C_SDA, VL53L0_I2C_SCL);
    /* creates the 53L0A1 expansion board singleton obj */
    board = XNucleo53L0A1::instance(device_i2c, A2, D8, D2);
    shdn = 0; //must reset sensor for an mbed reset to work
    wait(0.1);
    shdn = 1;
    wait(0.1);
    /* init the 53L0A1 board with default values */
    status = board->init_board();
    while (status) {
        pc.printf("Failed to init board! \r\n");
        status = board->init_board();
    }
    //loop taking and printing distance
    while (1) {
        status = board->sensor_centre->get_distance(&distance);
        if (status == VL53L0X_ERROR_NONE) {
            pc.printf("D=%ld mm\r\n", distance);
        }
    }
}
```

### Sonar sensor to measure distance

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018161418946.png" alt="image-20231018161418946" style="zoom:33%;" />

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20231018161405613.png" alt="image-20231018161405613" style="zoom:33%;" />

```c++
#include "mbed.h"

DigitalOut trigger(p6);
DigitalOut myled(LED1); //monitor trigger
DigitalOut myled2(LED2); //monitor echo
DigitalIn  echo(p7);
int distance = 0;
int correction = 0;
Timer sonar;

int main()
{
    sonar.reset();
// measure actual software polling timer delays
// delay used later in time correction
// start timer
    sonar.start();
// min software polling delay to read echo pin
    while (echo==2) {};
    myled2 = 0;
// stop timer
    sonar.stop();
// read timer
    correction = sonar.read_us();
    printf("Approximate software overhead timer delay is %d uS\n\r",correction);

//Loop to read Sonar distance values, scale, and print
    while(1) {
// trigger sonar to send a ping
        trigger = 1;
        myled = 1;
        myled2 = 0;
        sonar.reset();
        wait_us(10.0);
        trigger = 0;
        myled = 0;
//wait for echo high
        while (echo==0) {};
        myled2=echo;
//echo high, so start timer
        sonar.start();
//wait for echo low
        while (echo==1) {};
//stop timer and read value
        sonar.stop();
//subtract software overhead timer delay and scale to cm
        distance = (sonar.read_us()-correction)/58.0;
        myled2 = 0;
        printf(" %d cm \n\r",distance);
//wait so that any echo(s) return before sending another ping
        wait(0.2);
    }
}
```





## Lab3 code

```c++
 
#include "Semaphore.h"
#include "mbed.h"


#include "rtos.h"
#include "SDFileSystem.h"
#include "wave_player.h"
#include "uLCD_4DGL.h"
#include <mpr121.h>

uLCD_4DGL uLCD(p13,p14,p15); // serial tx, serial rx, reset pin;

SDFileSystem sd(p5, p6, p7, p8, "sd"); //SD card

AnalogOut DACout(p18);

wave_player waver(&DACout);

RawSerial  pc(USBTX, USBRX);
RawSerial  dev(p28,p27);

PwmOut ledr(p23);
PwmOut ledg(p24);
PwmOut ledb(p25);
// mutex to make the lcd lib thread safe
Mutex lcd_mutex;

DigitalIn Up(p26);
DigitalIn Down(p29);
DigitalIn Left(p28);
DigitalIn Right(p30);



//keypad
DigitalOut led1(LED1);
DigitalOut led2(LED2);
DigitalOut led3(LED3);
DigitalOut led4(LED4);

InterruptIn interrupt(p26);
I2C i2c(p9, p10);

// Setup the Mpr121:
// constructor(i2c object, i2c address of the mpr121)
Mpr121 mpr121(&i2c, Mpr121::ADD_VSS);

void fallInterrupt() {
    int key_code=0;
    int i=0;
    int value=mpr121.read(0x00);
    value +=mpr121.read(0x01)<<8;
    // LED demo mod by J. Hamblen
    //pc.printf("MPR value: %x \r\n", value);
    i=0;
    // puts key number out to LEDs for demo
    for (i=0; i<12; i++) {
        if (((value>>i)&0x01)==1) key_code=i+1;
        }
    led4=key_code & 0x01;
    led3=(key_code>>1) & 0x01;
    led2=(key_code>>2) & 0x01;
    led1=(key_code>>3) & 0x01;
}
// Thread 1
// RGB LED
void thread1(void const *args)
{
    while(true) {         // thread loop
        if(ledr==1)
        {
            lcd_mutex.lock();
            uLCD.filled_circle(60, 60, 15, RED);
            lcd_mutex.unlock();
        }
        else if(ledb==1)
        {
            lcd_mutex.lock();
            uLCD.filled_circle(60, 60, 15, WHITE);
            lcd_mutex.unlock();
        }
        else if(ledg==1)
        {
            lcd_mutex.lock();
            uLCD.filled_circle(60, 60, 15, GREEN);
            lcd_mutex.unlock();
        }
        else
        {
            lcd_mutex.lock();
            uLCD.filled_circle(60, 60, 15, BLUE);
            lcd_mutex.unlock();
        }
    }
}
void dev_recv(void const *args)
{
    while(1){
    char bnum=0;
    while(dev.readable()) {
        char temp = dev.getc();
        if (temp=='!') {
            if (dev.getc()=='B') { //button data
                pc.putc('B');
                bnum = dev.getc(); //button number
                pc.putc(bnum);
                if ((bnum>='1')&&(bnum<='3')) //is a number button 1..4
                {
                    temp = dev.getc();
                    if(bnum == '1'){
                        ledr = temp - '0';
                    }
                    else if(bnum == '2'){
                        ledg = temp - '0';
                    }
                    else{
                        ledb = temp - '0';
                    }
                    //myled[bnum-'1']=dev.getc()-'0'; //turn on/off that num LED
                }
            }
        }
    }
    }
}
void thread2(void const *args)
{
    lcd_mutex.lock();
    uLCD.printf("\nHello uLCD World\n"); //Default Green on black text
    uLCD.printf("\n  Starting Demo...");
    uLCD.text_height(4); //4X size text
    uLCD.text_height(4);
    uLCD.color(RED);
    lcd_mutex.unlock();
}

void thread3(void const *args)
{
    while(1){
    if(!Up){
        lcd_mutex.lock();
        uLCD.printf("\nUP\n");
        printf("\r\nUp!!!\n\r");
        lcd_mutex.unlock();
    }
    else if(!Down){
        lcd_mutex.lock();
        uLCD.printf("\nDOWN\n");
        printf("\r\nDown!!!\n\r");
        lcd_mutex.unlock();
    }
    else if(!Left){
        lcd_mutex.lock();
        uLCD.printf("\nLEFT\n");
        printf("\r\nLeft!!!\n\r");
        lcd_mutex.unlock();
    }
    else if(!Right){
        lcd_mutex.lock();
        uLCD.printf("\nRIGHT\n");
        printf("\r\nRight!!!\n\r");
        lcd_mutex.unlock();
    }
    }
}

int main()
{

    Thread t1(dev_recv);
    Thread t2(thread2);
    Thread t3(thread1);
    Thread t4(thread3);
    interrupt.fall(&fallInterrupt);
    interrupt.mode(PullUp);
    FILE *wave_file;
    printf("\r\n\nHello, wave world!\n\r");
    Thread::wait(1000);
    wave_file=fopen("/sd/sample1.wav","r");
    //wave_file=fopen("/sd/Drip.wav","r");
    if(wave_file==NULL) printf("file open error!\n\n\r");
    waver.play(wave_file);
    fclose(wave_file);
}
```

