# CS6422的学习笔记

## lecture Template

**内容概括：**😊



### 知识点1

**内容：**

* 
* 

### 知识点2

**内容：**

* 
* 

### 总结：



## Lecture1:

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20230831161757575.png" alt="image-20230831161757575" style="zoom: 33%;" />

这节课简单做了课程的介绍，以及database是一个难题，以及database的一些变化。

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20230831161906828.png" alt="image-20230831161906828" style="zoom:33%;" />

由于以前的main memory很小，所以Disk-Oriented设计是占主流的。

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20230831162003283.png" alt="image-20230831162003283" style="zoom:33%;" />

由于硬件的高速发展，对于CPU的发展优化变得重要。更多数据进入main memory处理。disk_oriented不再最优解。

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20230831162432518.png" alt="image-20230831162432518" style="zoom:33%;" />

关于databse的一些要求吧

### Conclusion：

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20230831171900655.png" alt="image-20230831171900655" style="zoom:33%;" />



## Lecture2

这节课引入了**Relational Model**。讲了Relational Model中的primary key 和Foreign Key.

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20230903212101358.png" alt="image-20230903212101358" style="zoom:33%;" />

首先简单介绍了这两个。 

Relational Algebra像SQL查询语言。

Relational Calculus像自然语言查询。

### Relational Algebra

Projection：

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20230903212803989.png" alt="image-20230903212803989" style="zoom:33%;" />

Union:

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20230903212823613.png" alt="image-20230903212823613" style="zoom:33%;" />

Intersection:

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20230903212856164.png" alt="image-20230903212856164" style="zoom:33%;" />

Difference:

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20230903212922572.png" alt="image-20230903212922572" style="zoom:33%;" />

Product:

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20230903212952964.png" alt="image-20230903212952964" style="zoom:33%;" />

Join: 

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20230903213011065.png" alt="image-20230903213011065" style="zoom:33%;" />

### Relational Language(SQL)

#### **Aggregates**

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20230903213309684.png" alt="image-20230903213309684" style="zoom:33%;" />

聚合函数通常在SELECT的句子中使用。

（MULTIPLE 聚合函数）：

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20230903213656675.png" alt="image-20230903213656675" style="zoom:33%;" />

DISTINCT和聚合函数：

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20230903213825289.png" alt="image-20230903213825289" style="zoom:33%;" />

#### **Grouping**

GROUP BY:

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20230903213921626.png" alt="image-20230903213921626" style="zoom:33%;" />

HAVING:

<img src="/Users/pb/Documents/My-study-notes/pictures/image-20230903214311907.png" alt="image-20230903214311907" style="zoom:33%;" />

对于table的筛选使用WHERE。对于聚合函数的结果，如这里的avg_grade，使用HAVING.

### Conclusion:

#### SQL的执行顺序：

1. `FROM` 子句：从指定的表或数据源中选择数据。
2. `WHERE` 子句：对从数据源中选择的行进行筛选，只保留满足条件的行。
3. `GROUP BY` 子句：将数据按照指定的列分组，生成分组的结果。
4. `HAVING` 子句：对分组后的结果应用筛选条件，只保留满足条件的分组。
5. `SELECT` 子句：选择要从查询结果中返回的列。
6. `ORDER BY` 子句：对结果进行排序（可选）。

在第三步和第四步中间发生聚合函数的计算。计算完HAVING进行筛选。

#### SQL的语法顺序：

```sql
SELECT column1, column2, ...# 需要的列
FROM table_name						#数据的来源。
WHERE condition 					# 筛选table信息
GROUP BY column_name
HAVING aggregate_condition		# 筛选聚合信息
ORDER BY column_name;				# 排序
```

所以SQL的执行顺序不是语法顺序！













